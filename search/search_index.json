{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#welcome-to-protodune-metadex","title":"Welcome to PROTODUNE-METADEX","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"architecture/event-storming/","title":"Event Storming: Metadata Management","text":""},{"location":"architecture/event-storming/#event-storming-metadata-management","title":"Event Storming: Metadata Management","text":"<p>Event storming is a collaborative technique used for domain discovery. It is typically conducted in a workshop setting and allows the stakeholders of a given domain to build a high-level model of its systems and related processes. While many concepts from Domain-Driven Design are used in event storming, it is not a strictly DDD focused technique.</p> <p>Most of the online resources related to event storming will show examples that are business domain oriented. We have taken the basic concepts from event storming and modified them to model the systems and processes involved in ProtoDUNE metadata management.</p>"},{"location":"architecture/event-storming/#notation","title":"Notation","text":"<p>There are many commonly adopted patterns for notation in event storming, but you will often see variation in the definitions, the color palette, and the flow of interactions that are used by different practitioners. As a general practice interactions, are time ordered; flowing from left to right, and from top to bottom. The following describes the basic notation used in the design of the ProtoDUNE metadata management process models.</p> <p>Event Storming Notation</p> <p></p> Notation Type Description <code>Bounded Context (Dashed Box)</code> An area of domain language consistency. A way to group all related domain events, entities, and their processes. <code>Actor (Light Yellow)</code> The users that participate in any process; they can be human, or computational. <code>Command (Blue)</code> The execution of an action. <code>Domain Event (Orange)</code> The result of an executed action. Considered the facts of a domain. <code>External System (Pink)</code> External platforms, APIs, sites, etc. <code>Policy (Purple)</code> A process that is called when something happens. <code>Aggregate (Yellow)</code> A top-level entity that encapsulates all of the domain rules, including the child entities involved in command execution. <code>Read Model (Green)</code> Data that needs to fetched from a source; often used to make process decisions. <code>Hotspot (Red)</code> Possible issues or items that we do not yet know how to handle. <code>Comment (Light Grey)</code> A callout indicating something of note."},{"location":"architecture/event-storming/#metadata-management-process-models","title":"Metadata Management Process Models","text":""},{"location":"architecture/event-storming/#interval-of-validity-iov","title":"Interval of Validity (IOV)","text":"<p>ProtoDUNE Interval of Validity Model</p> <p></p>"},{"location":"architecture/event-storming/#run-configuration","title":"Run Configuration","text":"<p>ProtoDUNE Run Configuration Process Model</p> <p></p>"},{"location":"architecture/event-storming/#beam-conditions-ifbeam","title":"Beam Conditions (IFBeam)","text":"<p>ProtoDUNE Beam Conditions Process Model</p> <p></p>"},{"location":"architecture/event-storming/#slow-controls","title":"Slow Controls","text":"<p>ProtoDUNE Slow Controls Process Model</p> <p></p>"},{"location":"architecture/event-storming/#offline-calibration","title":"Offline Calibration","text":"<p>ProtoDUNE Calibration Process Model</p> <p></p>"},{"location":"architecture/event-storming/#simulation","title":"Simulation","text":"<p>ProtoDUNE Simulation Metadata Management Process Model</p> <p></p>"},{"location":"architecture/event-storming/#data-quality-and-monitoring-dqm","title":"Data Quality and Monitoring (DQM)","text":"<p>(TBD) ProtoDUNE Data Quality and Monitoring Process Model</p>"},{"location":"reference/api/iov_controller/","title":"interface.api.iov_controller","text":""},{"location":"reference/api/iov_controller/#interfaceapiiov_controller","title":"<code>interface.api.iov_controller</code>","text":"<p>This part of the project documentation focuses on an information-oriented approach. Use it as a reference for the technical implementation of the <code>PROTODUNE-METADEX</code> project code.</p>"},{"location":"reference/api/iov_controller/#src.protodune_metadex.interface.api.iov_controller.IovController","title":"<code>IovController</code>","text":"<p>               Bases: <code>AbstractController</code></p> Source code in <code>src/protodune_metadex/interface/api/iov_controller.py</code> <pre><code>class IovController(AbstractController):\n    router = APIRouter(\n        prefix=\"/iovs\",\n        tags=[\"iovs\"],\n        responses={404: {\"description\": \"Not found\"}},\n    )\n\n    @router.post(\n        \"/\",\n        summary=\"Create an interval of validity record.\",\n    )\n    async def create(\n        dto: IovCreateDto,\n        db_session: AsyncSession = Depends(sqlite.get_async_session),\n        service: CreateIovService = Depends(CreateIovService),\n    ) -&gt; IovReadDto:\n        \"\"\"\n        Create an interval of validity with the following information:\n\n        - **version**: A user generated label to describe the version. It must be a unique label.\n        - **reason**: The reason for creating a new interval of validity.\n        \"\"\"\n        return await service(db_session, dto)\n\n    @router.get(\n        \"/{iov_id}\",\n        summary=\"Fetch an interval of validity using its ID.\",\n    )\n    async def get(\n        id: uuid.UUID,\n        db_session: AsyncSession = Depends(sqlite.get_async_session),\n        service: GetIovService = Depends(GetIovService),\n    ) -&gt; IovReadDto:\n        \"\"\"\n        Fetch an interval of validity record using its ID.\n        \"\"\"\n        return await service(db_session, id)\n\n    @router.get(\n        \"/\",\n        summary=\"Fetch all interval of validity records.\",\n    )\n    async def get_all(\n        db_session: AsyncSession = Depends(sqlite.get_async_session),\n        service: GetAllIovService = Depends(GetAllIovService),\n    ) -&gt; list[IovReadDto]:\n        \"\"\"\n        Fetch all interval of validity records.\n        \"\"\"\n        return await service(db_session)\n\n    @router.patch(\n        \"/{iov_id}\",\n        summary=\"Update an interval of validity record using its ID.\",\n    )\n    async def update(\n        id: uuid.UUID,\n        dto: IovUpdateDto,\n        db_session: AsyncSession = Depends(sqlite.get_async_session),\n        service: UpdateIovService = Depends(UpdateIovService),\n    ) -&gt; IovReadDto:\n        \"\"\"\n        Update an interval of validity record, using its ID, with the following information:\n\n        - **(Optional) version**: A user generated label to describe the version. It must be a unique label.\n        - **(Optional) reason**: The reason for creating a new interval of validity.\n        \"\"\"\n        return await service(db_session, dto, id)\n\n    @router.delete(\n        \"/{iov_id}\",\n        status_code=status.HTTP_204_NO_CONTENT,\n        summary=\"Delete an interval of validity record using its ID.\",\n    )\n    async def delete(\n        id: uuid.UUID,\n        db_session: AsyncSession = Depends(sqlite.get_async_session),\n        service: DeleteIovService = Depends(DeleteIovService),\n    ) -&gt; Response:\n        \"\"\"\n        Delete an interval of validity record using its ID.\n        \"\"\"\n        deleted = await service(db_session, id)\n\n        if not deleted:\n            raise HTTPException(status_code=404, detail=\"Iov not found\")\n\n        return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"reference/api/iov_controller/#src.protodune_metadex.interface.api.iov_controller.IovController.create","title":"<code>create(dto, db_session=Depends(sqlite.get_async_session), service=Depends(CreateIovService))</code>  <code>async</code>","text":"<p>Create an interval of validity with the following information:</p> <ul> <li>version: A user generated label to describe the version. It must be a unique label.</li> <li>reason: The reason for creating a new interval of validity.</li> </ul> Source code in <code>src/protodune_metadex/interface/api/iov_controller.py</code> <pre><code>@router.post(\n    \"/\",\n    summary=\"Create an interval of validity record.\",\n)\nasync def create(\n    dto: IovCreateDto,\n    db_session: AsyncSession = Depends(sqlite.get_async_session),\n    service: CreateIovService = Depends(CreateIovService),\n) -&gt; IovReadDto:\n    \"\"\"\n    Create an interval of validity with the following information:\n\n    - **version**: A user generated label to describe the version. It must be a unique label.\n    - **reason**: The reason for creating a new interval of validity.\n    \"\"\"\n    return await service(db_session, dto)\n</code></pre>"},{"location":"reference/api/iov_controller/#src.protodune_metadex.interface.api.iov_controller.IovController.delete","title":"<code>delete(id, db_session=Depends(sqlite.get_async_session), service=Depends(DeleteIovService))</code>  <code>async</code>","text":"<p>Delete an interval of validity record using its ID.</p> Source code in <code>src/protodune_metadex/interface/api/iov_controller.py</code> <pre><code>@router.delete(\n    \"/{iov_id}\",\n    status_code=status.HTTP_204_NO_CONTENT,\n    summary=\"Delete an interval of validity record using its ID.\",\n)\nasync def delete(\n    id: uuid.UUID,\n    db_session: AsyncSession = Depends(sqlite.get_async_session),\n    service: DeleteIovService = Depends(DeleteIovService),\n) -&gt; Response:\n    \"\"\"\n    Delete an interval of validity record using its ID.\n    \"\"\"\n    deleted = await service(db_session, id)\n\n    if not deleted:\n        raise HTTPException(status_code=404, detail=\"Iov not found\")\n\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n</code></pre>"},{"location":"reference/api/iov_controller/#src.protodune_metadex.interface.api.iov_controller.IovController.get","title":"<code>get(id, db_session=Depends(sqlite.get_async_session), service=Depends(GetIovService))</code>  <code>async</code>","text":"<p>Fetch an interval of validity record using its ID.</p> Source code in <code>src/protodune_metadex/interface/api/iov_controller.py</code> <pre><code>@router.get(\n    \"/{iov_id}\",\n    summary=\"Fetch an interval of validity using its ID.\",\n)\nasync def get(\n    id: uuid.UUID,\n    db_session: AsyncSession = Depends(sqlite.get_async_session),\n    service: GetIovService = Depends(GetIovService),\n) -&gt; IovReadDto:\n    \"\"\"\n    Fetch an interval of validity record using its ID.\n    \"\"\"\n    return await service(db_session, id)\n</code></pre>"},{"location":"reference/api/iov_controller/#src.protodune_metadex.interface.api.iov_controller.IovController.get_all","title":"<code>get_all(db_session=Depends(sqlite.get_async_session), service=Depends(GetAllIovService))</code>  <code>async</code>","text":"<p>Fetch all interval of validity records.</p> Source code in <code>src/protodune_metadex/interface/api/iov_controller.py</code> <pre><code>@router.get(\n    \"/\",\n    summary=\"Fetch all interval of validity records.\",\n)\nasync def get_all(\n    db_session: AsyncSession = Depends(sqlite.get_async_session),\n    service: GetAllIovService = Depends(GetAllIovService),\n) -&gt; list[IovReadDto]:\n    \"\"\"\n    Fetch all interval of validity records.\n    \"\"\"\n    return await service(db_session)\n</code></pre>"},{"location":"reference/api/iov_controller/#src.protodune_metadex.interface.api.iov_controller.IovController.update","title":"<code>update(id, dto, db_session=Depends(sqlite.get_async_session), service=Depends(UpdateIovService))</code>  <code>async</code>","text":"<p>Update an interval of validity record, using its ID, with the following information:</p> <ul> <li>(Optional) version: A user generated label to describe the version. It must be a unique label.</li> <li>(Optional) reason: The reason for creating a new interval of validity.</li> </ul> Source code in <code>src/protodune_metadex/interface/api/iov_controller.py</code> <pre><code>@router.patch(\n    \"/{iov_id}\",\n    summary=\"Update an interval of validity record using its ID.\",\n)\nasync def update(\n    id: uuid.UUID,\n    dto: IovUpdateDto,\n    db_session: AsyncSession = Depends(sqlite.get_async_session),\n    service: UpdateIovService = Depends(UpdateIovService),\n) -&gt; IovReadDto:\n    \"\"\"\n    Update an interval of validity record, using its ID, with the following information:\n\n    - **(Optional) version**: A user generated label to describe the version. It must be a unique label.\n    - **(Optional) reason**: The reason for creating a new interval of validity.\n    \"\"\"\n    return await service(db_session, dto, id)\n</code></pre>"}]}